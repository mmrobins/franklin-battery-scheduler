#!/usr/bin/env bash
# This script was generated by bashly 1.3.3 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
franklin_usage() {
  printf "franklin - A command line interface for interacting with the FranklinWH battery API.\n\n"

  printf "%s\n" "Usage:"
  printf "  franklin COMMAND\n"
  printf "  franklin [COMMAND] --help | -h\n"
  printf "  franklin --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Get an authentication token.  This will be done automatically when needed in other commands.\n" "get-token              "
  printf "  %s   Set the battery's state of charge and optionally mode.\n" "set-soc                "
  printf "  %s   Fetch the daily analytics data.\n" "fetch-daily-data       "
  printf "  %s   Fetch the fine-grained analytics data.\n" "fetch-fine-grained-data"
  printf "  %s   Clear the cached authentication token.\n" "clear-token            "
  printf "  %s   Fetch the current state of the battery.\n" "status                 "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "FRANKLIN_EMAIL (required)"
    printf "    Your FranklinWH account email.\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "FRANKLIN_PASSWORD (required)"
    printf "    Your FranklinWH account password.\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "FRANKLIN_GATEWAY_ID (required)"
    printf "    Your FranklinWH gateway ID.\n"
    echo

  fi
}

# :command.usage
franklin_get_token_usage() {
  printf "franklin get-token - Get an authentication token.  This will be done automatically when needed in other commands.\n\n"

  printf "%s\n" "Usage:"
  printf "  franklin get-token\n"
  printf "  franklin get-token --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
franklin_set_soc_usage() {
  printf "franklin set-soc - Set the battery's state of charge and optionally mode.\n\n"

  printf "%s\n" "Usage:"
  printf "  franklin set-soc SOC [MODE]\n"
  printf "  franklin set-soc --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOC"
    printf "    The state of charge to set (0-100).\n"
    echo

    # :argument.usage
    printf "  %s\n" "MODE"
    printf "    The mode to set (tou, self, backup).\n"
    printf "    %s\n" "Default: self"
    echo

  fi
}

# :command.usage
franklin_fetch_daily_data_usage() {
  printf "franklin fetch-daily-data - Fetch the daily analytics data.\n\n"

  printf "%s\n" "Usage:"
  printf "  franklin fetch-daily-data [OPTIONS]\n"
  printf "  franklin fetch-daily-data --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--start-date, -s DATE"
    printf "    The start date for the analytics data (YYYY-MM-DD).\n"
    echo

    # :flag.usage
    printf "  %s\n" "--end-date, -e DATE"
    printf "    The end date for the analytics data (YYYY-MM-DD).\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
franklin_fetch_fine_grained_data_usage() {
  printf "franklin fetch-fine-grained-data - Fetch the fine-grained analytics data.\n\n"

  printf "%s\n" "Usage:"
  printf "  franklin fetch-fine-grained-data [OPTIONS]\n"
  printf "  franklin fetch-fine-grained-data --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    The date for the analytics data (YYYY-MM-DD).\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
franklin_clear_token_usage() {
  printf "franklin clear-token - Clear the cached authentication token.\n\n"

  printf "%s\n" "Usage:"
  printf "  franklin clear-token\n"
  printf "  franklin clear-token --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
franklin_status_usage() {
  printf "franklin status - Fetch the current state of the battery.\n\n"

  printf "%s\n" "Usage:"
  printf "  franklin status\n"
  printf "  franklin status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/auth.sh
# Get an authentication token
function get_token() {
    if [ -f ".env" ]; then
        source .env
        if [ -n "$FRANKLIN_TOKEN" ]; then
            echo "Using cached token auth token from .env file." >&2
            echo "$FRANKLIN_TOKEN"
            return
        fi
    fi

    BASE_URL="https://energy.franklinwh.com/hes-gateway/terminal"

    echo "Logging in to get auth token..."

    # Get MD5 hash of password (using openssl on macOS)
    PASSWORD_HASH=$(echo -n "$FRANKLIN_PASSWORD" | openssl md5 | cut -d' ' -f2)

    if [ "$DEBUG" = "true" ]; then
        echo "DEBUG: Password hash: $PASSWORD_HASH"
    fi

    # Login to get token
    LOGIN_CMD="curl -s -X POST \"$BASE_URL/initialize/appUserOrInstallerLogin\" -d \"account=$FRANKLIN_EMAIL\" -d \"password=$PASSWORD_HASH\" -d \"lang=en_US\" -d \"type=1\""

    if [ "$DEBUG" = "true" ]; then
        echo "DEBUG: Running login command:"
        echo "DEBUG: $LOGIN_CMD"
    fi

    LOGIN_RESPONSE=$(eval "$LOGIN_CMD")

    if [ "$DEBUG" = "true" ]; then
        echo "DEBUG: Login response: $LOGIN_RESPONSE"
    fi

    # Extract token using grep and sed
    TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"token":"[^"]*"' | sed 's/"token":"//' | sed 's/"//')

    if [ -z "$TOKEN" ]; then
        echo "Error: Failed to get authentication token"
        echo "Response: $LOGIN_RESPONSE"
        exit 1
    fi

    echo "FRANKLIN_TOKEN=$TOKEN" > .env
    echo "$TOKEN"
}

# :command.command_functions
# :command.function
franklin_get_token_command() {

  # src/get_token_command.sh
  get_token

}

# :command.function
franklin_set_soc_command() {

  # src/set_soc_command.sh
  SOC=${args[soc]}
  MODE_ID=${args[mode]:-self}

  # Validate MODE_ID and set currendId and workMode
  case "$MODE_ID" in
      "tou") # Time of Use
          CURREND_ID="162382"
          WORK_MODE="1"
          MODE_NAME="Time of Use"
          ;;
      "self") # Self Consumption
          CURREND_ID="150521"
          WORK_MODE="2"
          MODE_NAME="Self Consumption"
          ;;
      "backup") # Emergency Backup
          CURREND_ID="150953"
          WORK_MODE="3"
          MODE_NAME="Emergency Backup"
          ;;
      *)
          echo "Error: Invalid mode_id. Allowed values are 'tou', 'self', or 'backup'."
          exit 1
          ;;
  esac

  # Validate SOC is a number between 0 and 100
  if ! [[ "$SOC" =~ ^[0-9]+$ ]] || [ "$SOC" -lt 0 ] || [ "$SOC" -gt 100 ]; then
      echo "Error: SOC must be a number between 0 and 100"
      exit 1
  fi

  BASE_URL="https://energy.franklinwh.com/hes-gateway/terminal"

  echo "Setting ${MODE_NAME} mode with ${SOC}% SOC..."

  TOKEN=$(get_token)
  if [ -z "$TOKEN" ]; then
      exit 1
  fi

  # Set battery mode with specified SOC
  if [ "$DEBUG" = "true" ]; then
      echo "DEBUG: Setting SOC URL: $BASE_URL/tou/updateTouMode"
      echo "DEBUG: Gateway ID: $FRANKLIN_GATEWAY_ID"
      echo "DEBUG: SOC: $SOC"
  fi

  SOC_CMD="curl -s -X POST \"$BASE_URL/tou/updateTouMode\" -H \"loginToken: $TOKEN\" -H \"Content-Type: application/x-www-form-urlencoded\" -d \"currendId=$CURREND_ID\" -d \"gatewayId=$FRANKLIN_GATEWAY_ID\" -d \"lang=EN_US\" -d \"oldIndex=1\" -d \"soc=$SOC\" -d \"stromEn=1\" -d \"workMode=$WORK_MODE\""

  if [ "$DEBUG" = "true" ]; then
      echo "DEBUG: Running SOC update command:"
      echo "DEBUG: $SOC_CMD"
  fi

  RESPONSE=$(eval "$SOC_CMD")

  if [ "$DEBUG" = "true" ]; then
      echo "DEBUG: Set SOC response: $RESPONSE"
  fi

  # Check if successful by looking for "code":200
  SUCCESS=$(echo "$RESPONSE" | grep -q '"code":200' && echo "success" || echo "failed")

  if [ "$DEBUG" = "true" ]; then
      echo "DEBUG: Success check result: $SUCCESS"
  fi

  if [ "$SUCCESS" = "success" ]; then
      echo "✓ Successfully set ${MODE_NAME} mode with ${SOC}% SOC"
  else
      echo "✗ Failed to set ${MODE_NAME} mode. Response:"
      echo "$RESPONSE"
      exit 1
  fi
}

# :command.function
franklin_fetch_daily_data_command() {

  # src/fetch_daily_data_command.sh
  START_DATE=${args[--start-date]}
  END_DATE=${args[--end-date]}

  # Set default date range (last 7 days)
  if [ -z "$START_DATE" ]; then
      START_DATE=$(date -v-7d +%Y-%m-%d)
  fi
  if [ -z "$END_DATE" ]; then
      END_DATE=$(date +%Y-%m-%d)
  fi

  BASE_URL="https://energy.franklinwh.com"
  ANALYTICS_DIR="analytics"
  CSV_FILE="$ANALYTICS_DIR/${START_DATE}_to_${END_DATE}_franklin_daily_analytics.csv"

  mkdir -p $ANALYTICS_DIR

  echo "Fetching daily analytics from $START_DATE to $END_DATE..."

  # Get auth token
  TOKEN=$(get_token)
  if [ -z "$TOKEN" ]; then
      exit 1
  fi

  # Write CSV header
  echo "deviceTime,kwhSu,kwhGen,kwhUtiIn,kwhUtiOut,kwhFhpChg,kwhFhpDi,kwhLoad,kwhGridLoad,kwhSolarLoad,kwhFhpLoad,kwhGenLoad,gridChBat,batOutGrid,genChBat,soChBat,soOutGrid" > $CSV_FILE

  # Loop through dates
  CURRENT_DATE=$START_DATE
  while [ "$CURRENT_DATE" != "$END_DATE" ]; do
      echo "Fetching data for $CURRENT_DATE..."

      # Fetch data for the current date
      API_RESPONSE=$(curl -s -X GET "$BASE_URL/api-energy/electric/getFhpElectricData?gatewayId=$FRANKLIN_GATEWAY_ID&type=1&dayTime=$CURRENT_DATE" -H "loginToken: $TOKEN")

      # Parse JSON and append to CSV
      echo "$API_RESPONSE" | jq -r '.result | [.deviceTimeArray, .kwhSuArray, .kwhGenArray, .kwhUtiInArray, .kwhUtiOutArray, .kwhFhpChgArray, .kwhFhpDiArray, .kwhLoadArray, .kwhGridLoadArray, .kwhSolarLoadArray, .kwhFhpLoadArray, .kwhGenLoadArray, .gridChBatArray, .batOutGridArray, .genChBatArray, .soChBatArray, .soOutGridArray] | transpose | .[] | @csv' >> $CSV_FILE

      CURRENT_DATE=$(date -j -v+1d -f "%Y-%m-%d" "$CURRENT_DATE" +%Y-%m-%d)
  done

  echo "Daily analytics data saved to $CSV_FILE"
}

# :command.function
franklin_fetch_fine_grained_data_command() {

  # src/fetch_fine_grained_data_command.sh
  DATE=${args[--date]}

  # Set default date (today)
  if [ -z "$DATE" ]; then
      DATE=$(date +%Y-%m-%d)
  fi

  BASE_URL="https://energy.franklinwh.com"
  ANALYTICS_DIR="analytics"
  CSV_FILE="$ANALYTICS_DIR/${DATE}_franklin_fine_grained_analytics.csv"

  mkdir -p $ANALYTICS_DIR

  echo "Fetching fine-grained analytics for $DATE..."

  # Get auth token
  TOKEN=$(get_token)
  if [ -z "$TOKEN" ]; then
      exit 1
  fi

  # Write CSV header
  echo "deviceTime,powerSolarHome,powerSolarGird,powerSolarFhp,powerGirdFhp,powerGirdHome,powerFhpGird,powerFhpHome,powerGenFhp,powerGenHome" > $CSV_FILE

  # Fetch data
  API_RESPONSE=$(curl -s -X GET "$BASE_URL/api-energy/power/getFhpPowerByDay?gatewayId=$FRANKLIN_GATEWAY_ID&dayTime=$DATE" -H "loginToken: $TOKEN")

  if [ "$DEBUG" = "true" ]; then
      echo "DEBUG: API Response for $DATE:"
      echo "$API_RESPONSE"
  fi

  # Parse JSON and append to CSV
  echo "$API_RESPONSE" | jq -r '.result | [.deviceTimeArray, .powerSolarHomeArray, .powerSolarGirdArray, .powerSolarFhpArray, .powerGirdFhpArray, .powerGirdHomeArray, .powerFhpGirdArray, .powerFhpHomeArray, .powerGenFhpArray, .powerGenHomeArray] | transpose | .[] | @csv' >> $CSV_FILE

  echo "Fine-grained analytics data saved to $CSV_FILE"
}

# :command.function
franklin_clear_token_command() {

  # src/clear_token_command.sh
  rm -f .env
  echo "Cached token cleared."

}

# :command.function
franklin_status_command() {

  # src/status_command.sh
  TOKEN=$(get_token)
  if [ -z "$TOKEN" ]; then
      exit 1
  fi

  BASE_URL="https://energy.franklinwh.com"

  API_RESPONSE=$(curl -s -X GET "$BASE_URL/hes-gateway/terminal/getDeviceCompositeInfo?gatewayId=$FRANKLIN_GATEWAY_ID&refreshFlag=1" -H "loginToken: $TOKEN")

  if [ "$DEBUG" = "true" ]; then
      echo "DEBUG: API Response:"
      echo "$API_RESPONSE"
  fi

  SOC=$(echo "$API_RESPONSE" | jq -r '.result.runtimeData.soc')
  MODE=$(echo "$API_RESPONSE" | jq -r '.result.runtimeData.mode')
  KWH_USED_TODAY=$(echo "$API_RESPONSE" | jq -r '.result.runtimeData.kwh_load')
  KWH_PRODUCED_TODAY=$(echo "$API_RESPONSE" | jq -r '.result.runtimeData.kwh_sun')
  PANEL_CONSUMING=$(echo "$API_RESPONSE" | jq -r '.result.runtimeData.p_load')
  PANEL_PRODUCING=$(echo "$API_RESPONSE" | jq -r '.result.runtimeData.p_sun')
  GRID_DRAW=$(echo "$API_RESPONSE" | jq -r '.result.runtimeData.p_uti')

  # Get the currently set SOC values for each mode from the TOU List V2 endpoint
  TOU_LIST_RESPONSE=$(curl -s -X POST "$BASE_URL/hes-gateway/terminal/tou/getGatewayTouListV2?gatewayId=$FRANKLIN_GATEWAY_ID&showType=1" -H "loginToken: $TOKEN" -H "Content-Type: application/json" -d "")

  if [ "$DEBUG" = "true" ]; then
      echo "DEBUG: TOU List V2 Response:"
      echo "$TOU_LIST_RESPONSE"
  fi

  # Extract the currently set SOC for the current mode (this represents the minimum SOC setting)
  # From the API response, the 'soc' field contains the currently set SOC value for each mode
  case "$MODE" in
      "150521")  # Self Consumption
          MIN_SOC=$(echo "$TOU_LIST_RESPONSE" | jq -r '.result?.list[]? | select(.id == 150521) | .soc // empty')
          ;;
      "162382")  # Time of Use
          MIN_SOC=$(echo "$TOU_LIST_RESPONSE" | jq -r '.result?.list[]? | select(.id == 162382) | .soc // empty')
          ;;
      "150953")  # Emergency Backup
          MIN_SOC=$(echo "$TOU_LIST_RESPONSE" | jq -r '.result?.list[]? | select(.id == 150953) | .soc // empty')
          ;;
      *)
          # For any other mode, try to get the SOC regardless of mode
          MIN_SOC=$(echo "$TOU_LIST_RESPONSE" | jq -r '.result?.list[]? | .soc // empty' | head -n 1)
          ;;
  esac

  case "$MODE" in
      "150521")
          MODE_NAME="Self Consumption"
          ;;
      "162382")
          MODE_NAME="Time of Use"
          ;;
      "150953")
          MODE_NAME="Emergency Backup"
          ;;
      *)
          MODE_NAME="Unknown"
          ;;
  esac

  echo "SOC: $SOC%"
  if [ -n "$MIN_SOC" ] && [ "$MIN_SOC" != "null" ] && [ "$MIN_SOC" != "empty" ]; then
      echo "Min SOC: $MIN_SOC%"
  else
      # Provide an informative message about where min SOC is usually configured
      echo "Min SOC: Not available (typically configured via app at 20%)"
  fi
  echo "Mode: $MODE_NAME"
  echo "kWh Used Today: $KWH_USED_TODAY"
  echo "kWh Produced Today: $KWH_PRODUCED_TODAY"
  echo "Home Consuming: $PANEL_CONSUMING kW"
  echo "Panel Producing: $PANEL_PRODUCING kW"

  if (( $(echo "$GRID_DRAW > 0" | bc -l) )); then
      echo "Grid Draw: $GRID_DRAW kW"
  else
      echo "Grid Send: $(echo "$GRID_DRAW * -1" | bc -l) kW"
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        franklin_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("FRANKLIN_EMAIL")
  env_var_names+=("FRANKLIN_PASSWORD")
  env_var_names+=("FRANKLIN_GATEWAY_ID")
  if [[ -z "${FRANKLIN_EMAIL:-}" ]]; then
    printf "missing required environment variable: FRANKLIN_EMAIL\n" >&2
    exit 1
  fi
  if [[ -z "${FRANKLIN_PASSWORD:-}" ]]; then
    printf "missing required environment variable: FRANKLIN_PASSWORD\n" >&2
    exit 1
  fi
  if [[ -z "${FRANKLIN_GATEWAY_ID:-}" ]]; then
    printf "missing required environment variable: FRANKLIN_GATEWAY_ID\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    get-token)
      action="get-token"
      shift
      franklin_get_token_parse_requirements "$@"
      shift $#
      ;;

    set-soc)
      action="set-soc"
      shift
      franklin_set_soc_parse_requirements "$@"
      shift $#
      ;;

    fetch-daily-data)
      action="fetch-daily-data"
      shift
      franklin_fetch_daily_data_parse_requirements "$@"
      shift $#
      ;;

    fetch-fine-grained-data)
      action="fetch-fine-grained-data"
      shift
      franklin_fetch_fine_grained_data_parse_requirements "$@"
      shift $#
      ;;

    clear-token)
      action="clear-token"
      shift
      franklin_clear_token_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      franklin_status_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      franklin_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
franklin_get_token_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        franklin_get_token_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="get-token"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
franklin_set_soc_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        franklin_set_soc_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="set-soc"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['soc']+x} ]]; then
          args['soc']=$1
          shift
        # :argument.case
        elif [[ -z ${args['mode']+x} ]]; then
          args['mode']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['soc']+x} ]]; then
    printf "missing required argument: SOC\nusage: franklin set-soc SOC [MODE]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['mode']:-} ]] || args['mode']="self"

}

# :command.parse_requirements
franklin_fetch_daily_data_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        franklin_fetch_daily_data_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fetch-daily-data"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --start-date | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--start-date']="$2"
          shift
          shift
        else
          printf "%s\n" "--start-date requires an argument: --start-date, -s DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --end-date | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--end-date']="$2"
          shift
          shift
        else
          printf "%s\n" "--end-date requires an argument: --end-date, -e DATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
franklin_fetch_fine_grained_data_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        franklin_fetch_fine_grained_data_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fetch-fine-grained-data"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
franklin_clear_token_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        franklin_clear_token_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clear-token"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
franklin_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        franklin_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="1.0.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "get-token") franklin_get_token_command ;;
    "set-soc") franklin_set_soc_command ;;
    "fetch-daily-data") franklin_fetch_daily_data_command ;;
    "fetch-fine-grained-data") franklin_fetch_fine_grained_data_command ;;
    "clear-token") franklin_clear_token_command ;;
    "status") franklin_status_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
